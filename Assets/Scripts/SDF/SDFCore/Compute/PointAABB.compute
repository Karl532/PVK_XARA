#pragma kernel CSInit
#pragma kernel CSReduce

StructuredBuffer<float4> _Points;

RWStructuredBuffer<float3> _GroupAabbs; // layout: [group*2 + 0]=min, [group*2+1]=max
RWStructuredBuffer<float3> _OutAabbs;   // same layout for reduction output

int _PointCount;
int _AabbCount; // number of AABBs in _GroupAabbs / 2

[numthreads(256,1,1)]
void CSInit(uint3 id : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint3 tid : SV_GroupThreadID)
{
    uint idx = id.x;
    float3 p = (idx < (uint)_PointCount) ? _Points[idx].xyz : float3(1e20, 1e20, 1e20);
    float3 q = (idx < (uint)_PointCount) ? _Points[idx].xyz : float3(-1e20,-1e20,-1e20);

    // group shared reduce
    groupshared float3 sMin[256];
    groupshared float3 sMax[256];
    sMin[tid.x] = p;
    sMax[tid.x] = q;
    GroupMemoryBarrierWithGroupSync();

    for (uint stride = 128; stride > 0; stride >>= 1)
    {
        if (tid.x < stride)
        {
            sMin[tid.x] = min(sMin[tid.x], sMin[tid.x + stride]);
            sMax[tid.x] = max(sMax[tid.x], sMax[tid.x + stride]);
        }
        GroupMemoryBarrierWithGroupSync();
    }

    if (tid.x == 0)
    {
        uint base = gid.x * 2;
        _GroupAabbs[base + 0] = sMin[0];
        _GroupAabbs[base + 1] = sMax[0];
    }
}

[numthreads(256,1,1)]
void CSReduce(uint3 id : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint3 tid : SV_GroupThreadID)
{
    // Each input AABB occupies 2 float3 entries
    uint aabbIndex = id.x;
    uint inBase = aabbIndex * 2;

    float3 mn = (aabbIndex < (uint)_AabbCount) ? _GroupAabbs[inBase + 0] : float3(1e20,1e20,1e20);
    float3 mx = (aabbIndex < (uint)_AabbCount) ? _GroupAabbs[inBase + 1] : float3(-1e20,-1e20,-1e20);

    groupshared float3 sMin[256];
    groupshared float3 sMax[256];
    sMin[tid.x] = mn;
    sMax[tid.x] = mx;
    GroupMemoryBarrierWithGroupSync();

    for (uint stride = 128; stride > 0; stride >>= 1)
    {
        if (tid.x < stride)
        {
            sMin[tid.x] = min(sMin[tid.x], sMin[tid.x + stride]);
            sMax[tid.x] = max(sMax[tid.x], sMax[tid.x + stride]);
        }
        GroupMemoryBarrierWithGroupSync();
    }

    if (tid.x == 0)
    {
        uint outBase = gid.x * 2;
        _OutAabbs[outBase + 0] = sMin[0];
        _OutAabbs[outBase + 1] = sMax[0];
    }
}
